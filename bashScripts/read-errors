#!/bin/bash
#make bash fall over better
set -o pipefail

#this script relies on there being a file generated call logschanged which tells it what files
#to look at for errors.  This file will be generated by setup-watches (bash function)

#dictionary of package names to directories
#this is for when they don't match up
declare -A packageMapping=( 
  ["tracs-enterprise"]="haskell-service"
)

tempFile=.errors-temp
rm -f $tempFile
#'.*/(.+)-[0-9.]+.log' 
#regex for getting package name
extractPackageName='.*/(.+)-[0-9.]+(-test)?\.log'
#remove duplicates and colour logs (this avoids having copies with garbled characters in)
awk '!seen[$0]++' logschanged | grep -v '\-color$' | while read file 
do
  if [[ $file =~ $extractPackageName ]]; then
      #fullmatch=${BASH_REMATCH[0]}
      packageName=${BASH_REMATCH[1]}
      packagePath=${packageMapping[$packageName]}
      if [ -z "$packagePath" ]; then
          packagePath="$packageName"
      fi

      #grep sometimes thinks the files are binary when they aren't, -a corrects this
      #add in the file this has come from to aid with debugging
      grep -a 'error:\|warning:' $file | awk '{print $0 " '$file'"}' | sed '/no location info/d' | sed "s@^@$packagePath/@" >>$tempFile
  else
      echo "couldn't parse $file"
  fi
done 
#first strip out the debug info then remove duplicates and sort so that errors are at the bottom (-r reverses). secondary sort is by line number and then column 
sed s/'\S\+'$// $tempFile | awk '!seen[$0]++' | sort -t: -k4,4r -k1,1 -k2,3n > .errors 
rm $tempFile 
