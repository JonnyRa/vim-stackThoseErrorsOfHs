#!/bin/bash
#make bash fall over better
set -o pipefail

#this script relies on there being a file generated call logschanged which tells it what files
#to look at for errors.  This file will be generated by setup-watches (bash function)

#dictionary of package names to directories
#this is for when they don't match up
declare -A packageMapping=( 
  ["tracs-enterprise"]="haskell-service"
)

tempFile=.errors-temp
rm -f $tempFile
#'.*/(.+)-[0-9.]+.log' 
#regex for getting package name
extractPackageName='.*/(.+)-[0-9.]+(-test)?\.log'
#remove duplicates and colour logs (this avoids having copies with garbled characters in)
awk '!seen[$0]++' logschanged | grep -v '\-color$' | while read file 
do
  if [[ $file =~ $extractPackageName ]]; then
      #fullmatch=${BASH_REMATCH[0]}
      packageName=${BASH_REMATCH[1]}
      packagePath=${packageMapping[$packageName]}
      if [ -z "$packagePath" ]; then
          packagePath="$packageName"
      fi

      #grep sometimes thinks the files are binary when they aren't, -a corrects this
      grep -a 'error:\|warning:' $file | sed "s@^@$packagePath/@" >>$tempFile
  else
      echo "couldn't parse $file"
  fi
done 
#remove duplicates (if come from multiple files) and sort so that errors are at the bottom (-r reverses)
awk '!seen[$0]++' $tempFile | sort -t: -k4 -r > .errors 
rm $tempFile 
